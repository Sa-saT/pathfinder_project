This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  assets/
    css/
      style.css
  components/
    AuthForm.vue
    SoundPlayer.vue
    SoundUpload.vue
  layouts/
    default.vue
  pages/
    index.vue
  stores/
    auth.ts
    sounds.ts
  app.vue
database/
  init.sql
public/
  robots.txt
server/
  api/
    auth/
      login.post.ts
      me.get.ts
      register.post.ts
    sounds/
      [id]/
        download.get.ts
        stream.get.ts
      list.get.ts
      metadata.post.ts
      upload-local.post.ts
      upload-url.post.ts
  utils/
    db.ts
    localStorage.ts
storage/
  thumbnails/
    .gitkeep
  uploads/
    .gitkeep
.cursorrules
.gitignore
nuxt.config.ts
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/stores/auth.ts">
import { defineStore } from 'pinia'

interface User {
  id: string
  email: string
  displayName?: string
  createdAt?: string
}

interface AuthState {
  user: User | null
  isAuthenticated: boolean
  loading: boolean
}

export const useAuthStore = defineStore('auth', {
  state: (): AuthState => {
    // sessionStorageã‹ã‚‰åˆæœŸçŠ¶æ…‹ã‚’å¾©å…ƒ
    if (typeof window !== 'undefined') {
      const savedUser = sessionStorage.getItem('auth_user')
      const savedAuth = sessionStorage.getItem('auth_isAuthenticated')
      
      if (savedUser && savedAuth === 'true') {
        return {
          user: JSON.parse(savedUser),
          isAuthenticated: true,
          loading: false
        }
      }
    }
    
    return {
      user: null,
      isAuthenticated: false,
      loading: false
    }
  },

  getters: {
    currentUser: (state) => state.user,
    isLoggedIn: (state) => state.isAuthenticated
  },

  actions: {
    async login(email: string, password: string) {
      this.loading = true
      try {
        const response = await $fetch('/api/auth/login', {
          method: 'POST',
          body: { email, password }
        }) as any

        if (response.success) {
          this.user = response.user
          this.isAuthenticated = true
          
          // sessionStorageã«ä¿å­˜
          if (typeof window !== 'undefined') {
            sessionStorage.setItem('auth_user', JSON.stringify(response.user))
            sessionStorage.setItem('auth_isAuthenticated', 'true')
          }
          
          return { success: true, user: response.user }
        }
        return { success: false, error: 'Login failed' }
      } catch (error: any) {
        return { success: false, error: error.data?.message || 'Login failed' }
      } finally {
        this.loading = false
      }
    },

    async register(email: string, password: string, displayName?: string) {
      this.loading = true
      try {
        const response = await $fetch('/api/auth/register', {
          method: 'POST',
          body: { email, password, displayName }
        }) as any

        if (response.success) {
          this.user = response.user
          this.isAuthenticated = true
          
          // sessionStorageã«ä¿å­˜
          if (typeof window !== 'undefined') {
            sessionStorage.setItem('auth_user', JSON.stringify(response.user))
            sessionStorage.setItem('auth_isAuthenticated', 'true')
          }
          
          return { success: true, user: response.user }
        }
        return { success: false, error: 'Registration failed' }
      } catch (error: any) {
        return { success: false, error: error.data?.message || 'Registration failed' }
      } finally {
        this.loading = false
      }
    },

    async checkAuth() {
      try {
        const response = await $fetch('/api/auth/me') as any
        if (response.success) {
          this.user = response.user
          this.isAuthenticated = true
          
          // sessionStorageã«ä¿å­˜
          if (typeof window !== 'undefined') {
            sessionStorage.setItem('auth_user', JSON.stringify(response.user))
            sessionStorage.setItem('auth_isAuthenticated', 'true')
          }
          
          return true
        }
        return false
      } catch (error) {
        this.user = null
        this.isAuthenticated = false
        
        // sessionStorageã‹ã‚‰å‰Šé™¤
        if (typeof window !== 'undefined') {
          sessionStorage.removeItem('auth_user')
          sessionStorage.removeItem('auth_isAuthenticated')
        }
        
        return false
      }
    },

    logout() {
      // Cookieã‚’å‰Šé™¤
      document.cookie = 'Authorization=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'
      this.user = null
      this.isAuthenticated = false
      
      // sessionStorageã‹ã‚‰å‰Šé™¤
      if (typeof window !== 'undefined') {
        sessionStorage.removeItem('auth_user')
        sessionStorage.removeItem('auth_isAuthenticated')
      }
    }
  }
})
</file>

<file path="app/stores/sounds.ts">
import { defineStore } from 'pinia'

interface Sound {
  id: string
  title: string
  description?: string
  tags?: string[]
  durationSeconds?: number
  bitrateKbps?: number
  blobUrl: string
  thumbnailBlobUrl?: string
  isPublic: boolean
  createdAt: string
  author?: {
    email: string
    displayName?: string
  }
}

interface SoundsState {
  sounds: Sound[]
  loading: boolean
  error: string | null
}

export const useSoundsStore = defineStore('sounds', {
  state: (): SoundsState => {
    // sessionStorageã‹ã‚‰åˆæœŸçŠ¶æ…‹ã‚’å¾©å…ƒ
    if (typeof window !== 'undefined') {
      const savedSounds = sessionStorage.getItem('sounds_list')
      if (savedSounds) {
        try {
          return {
            sounds: JSON.parse(savedSounds),
            loading: false,
            error: null
          }
        } catch (e) {
          console.warn('Failed to parse saved sounds from sessionStorage')
        }
      }
    }
    
    return {
      sounds: [],
      loading: false,
      error: null
    }
  },

  getters: {
    publicSounds: (state) => state.sounds.filter(sound => sound.isPublic),
    soundsByTag: (state) => (tag: string) => 
      state.sounds.filter(sound => sound.tags?.includes(tag))
  },

  actions: {
    async fetchSounds() {
      this.loading = true
      this.error = null
      try {
        const response = await $fetch('/api/sounds/list') as any
        if (response.success) {
          this.sounds = response.sounds
          
          // sessionStorageã«ä¿å­˜
          if (typeof window !== 'undefined') {
            sessionStorage.setItem('sounds_list', JSON.stringify(response.sounds))
          }
        }
      } catch (error: any) {
        this.error = error.data?.message || 'Failed to fetch sounds'
        console.error('Error fetching sounds:', error)
      } finally {
        this.loading = false
      }
    },

    async uploadSound(soundData: FormData) {
      this.loading = true
      this.error = null
      try {
        const response = await $fetch('/api/sounds/upload-local', {
          method: 'POST',
          body: soundData
        }) as any

        if (response.success) {
          // æ–°ã—ãã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸéŸ³æºã‚’ä¸€è¦§ã®å…ˆé ­ã«è¿½åŠ 
          this.sounds.unshift(response.sound)
          return { success: true, sound: response.sound }
        }
        return { success: false, error: 'Upload failed' }
      } catch (error: any) {
        this.error = error.data?.message || 'Upload failed'
        return { success: false, error: this.error }
      } finally {
        this.loading = false
      }
    },

    addSound(sound: Sound) {
      this.sounds.unshift(sound)
    },

    removeSound(soundId: string) {
      const index = this.sounds.findIndex(sound => sound.id === soundId)
      if (index !== -1) {
        this.sounds.splice(index, 1)
      }
    },

    clearError() {
      this.error = null
    }
  }
})
</file>

<file path=".cursorrules">
# Pathfinder Audio App - Cursor Rules

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
- Nuxt4 + Vercel Blob + PostgreSQL éŸ³æºã‚¢ãƒ—ãƒª
- èªè¨¼: JWT + bcrypt
- çŠ¶æ…‹ç®¡ç†: Pinia + sessionStorage
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: DDLç›´æ¥å®Ÿè¡Œï¼ˆORMä¸ä½¿ç”¨ï¼‰
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸: é–‹ç™ºç’°å¢ƒã¯ãƒ­ãƒ¼ã‚«ãƒ«ã€æœ¬ç•ªã¯Vercel Blob

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: Nuxt 4, Vue 3, TypeScript, Pinia
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**: Nuxt Nitro, Node.js
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: PostgreSQL
- **ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸**: Vercel Blob (æœ¬ç•ª), ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ  (é–‹ç™º)
- **èªè¨¼**: JWT, bcrypt
- **ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼**: pnpm

## ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„
- TypeScriptå³æ ¼ãƒ¢ãƒ¼ãƒ‰
- Vue 3 Composition API
- Nuxt 4ã®è¦ç´„ã«æº–æ‹ 
- æ—¥æœ¬èªã‚³ãƒ¡ãƒ³ãƒˆæ¨å¥¨
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯é©åˆ‡ã«å®Ÿè£…

## ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ 
- `app/`: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼ˆVueã€Piniaã€ãƒšãƒ¼ã‚¸ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰
- `server/`: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆAPIã€ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã€ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼‰
- `database/`: SQLã‚¹ã‚­ãƒ¼ãƒã¨åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
- `storage/`: ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç”¨ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ï¼ˆuploads, thumbnailsï¼‰
- `public/`: é™çš„ãƒ•ã‚¡ã‚¤ãƒ«

## å‘½åè¦å‰‡
- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ: PascalCase (ä¾‹: AuthForm.vue)
- ãƒ•ã‚¡ã‚¤ãƒ«: kebab-case (ä¾‹: auth-form.vue)
- é–¢æ•°: camelCase (ä¾‹: handleAuthSuccess)
- å®šæ•°: UPPER_SNAKE_CASE (ä¾‹: JWT_SECRET)
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒ–ãƒ«: snake_case (ä¾‹: login_accounts)

## APIè¨­è¨ˆåŸå‰‡
- RESTful APIè¨­è¨ˆ
- é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰
- ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®çµ±ä¸€
- JWTèªè¨¼ã®é©åˆ‡ãªå®Ÿè£…

## çŠ¶æ…‹ç®¡ç†
- Piniaã‚¹ãƒˆã‚¢ã‚’ä½¿ç”¨
- sessionStorageã§ãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰æ™‚ã®çŠ¶æ…‹ä¿æŒ
- ã‚¹ãƒˆã‚¢ã¯`app/stores/`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯bcryptã§ãƒãƒƒã‚·ãƒ¥åŒ–
- JWTãƒˆãƒ¼ã‚¯ãƒ³ã®é©åˆ‡ãªç®¡ç†
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®æ¤œè¨¼
- SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–

## é–‹ç™ºç’°å¢ƒ
- ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºæ™‚ã¯`storage/`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½¿ç”¨
- æœ¬ç•ªç’°å¢ƒã§ã¯Vercel Blobã‚’ä½¿ç”¨
- ç’°å¢ƒå¤‰æ•°ã¯`.env`ã§ç®¡ç†
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã¯`runtimeConfig`ã§ç®¡ç†

## ãƒ†ã‚¹ãƒˆã¨ãƒ‡ãƒãƒƒã‚°
- é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•: `pnpm dev`
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–: `psql -d pathfinder -f database/init.sql`
- ãƒ­ã‚°ã¯é©åˆ‡ã«å‡ºåŠ›
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯è©³ç´°ã«å®Ÿè£…
</file>

<file path="app/assets/css/style.css">
@import "tailwindcss";
</file>

<file path="app/components/AuthForm.vue">
<template>
  <div class="auth-form">
    <div class="tabs">
      <button 
        :class="{ active: isLogin }" 
        @click="isLogin = true"
        class="tab-btn"
      >
        ãƒ­ã‚°ã‚¤ãƒ³
      </button>
      <button 
        :class="{ active: !isLogin }" 
        @click="isLogin = false"
        class="tab-btn"
      >
        æ–°è¦ç™»éŒ²
      </button>
    </div>

    <form @submit.prevent="handleSubmit" class="form">
      <div class="form-group">
        <label for="email">ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</label>
        <input
          id="email"
          v-model="form.email"
          type="email"
          required
          class="input"
          placeholder="example@example.com"
        />
      </div>

      <div class="form-group">
        <label for="password">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</label>
        <input
          id="password"
          v-model="form.password"
          type="password"
          required
          class="input"
          placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›"
        />
      </div>

      <div v-if="!isLogin" class="form-group">
        <label for="displayName">è¡¨ç¤ºåï¼ˆä»»æ„ï¼‰</label>
        <input
          id="displayName"
          v-model="form.displayName"
          type="text"
          class="input"
          placeholder="è¡¨ç¤ºåã‚’å…¥åŠ›"
        />
      </div>

      <button type="submit" class="submit-btn" :disabled="loading">
        {{ loading ? 'å‡¦ç†ä¸­...' : (isLogin ? 'ãƒ­ã‚°ã‚¤ãƒ³' : 'æ–°è¦ç™»éŒ²') }}
      </button>
    </form>

    <div v-if="error" class="error">
      {{ error }}
    </div>
  </div>
</template>

<script setup lang="ts">
const isLogin = ref(true)
const loading = ref(false)
const error = ref('')

const form = reactive({
  email: '',
  password: '',
  displayName: ''
})

const emit = defineEmits<{
  success: [user: any]
}>()

const handleSubmit = async () => {
  try {
    loading.value = true
    error.value = ''

    const endpoint = isLogin.value ? '/api/auth/login' : '/api/auth/register'
    const payload = isLogin.value 
      ? { email: form.email, password: form.password }
      : { email: form.email, password: form.password, displayName: form.displayName }

    const response = await $fetch(endpoint, {
      method: 'POST',
      body: payload
    })

    if (response.success) {
      emit('success', response.user)
      // ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
      form.email = ''
      form.password = ''
      form.displayName = ''
    }
  } catch (err: any) {
    error.value = err.data?.message || 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.auth-form {
  max-width: 400px;
  margin: 0 auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.tabs {
  display: flex;
  margin-bottom: 2rem;
  border-bottom: 2px solid #e5e7eb;
}

.tab-btn {
  flex: 1;
  padding: 1rem;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 1rem;
  color: #6b7280;
  transition: all 0.2s;
}

.tab-btn.active {
  color: #3b82f6;
  border-bottom: 2px solid #3b82f6;
}

.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: #374151;
}

.input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 1rem;
  transition: border-color 0.2s;
}

.input:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.submit-btn {
  width: 100%;
  padding: 0.75rem;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.submit-btn:hover:not(:disabled) {
  background: #2563eb;
}

.submit-btn:disabled {
  background: #9ca3af;
  cursor: not-allowed;
}

.error {
  margin-top: 1rem;
  padding: 0.75rem;
  background: #fef2f2;
  color: #dc2626;
  border: 1px solid #fecaca;
  border-radius: 6px;
  text-align: center;
}
</style>
</file>

<file path="app/components/SoundPlayer.vue">
<template>
  <div class="sound-player">
    <div class="sound-info">
      <h3>{{ sound.title }}</h3>
      <p v-if="sound.description" class="description">{{ sound.description }}</p>
      
      <div v-if="sound.tags && sound.tags.length > 0" class="tags">
        <span 
          v-for="tag in sound.tags" 
          :key="tag" 
          class="tag"
        >
          {{ tag }}
        </span>
      </div>

      <div class="metadata">
        <span v-if="sound.durationSeconds" class="duration">
          é•·ã•: {{ formatDuration(sound.durationSeconds) }}
        </span>
        <span v-if="sound.bitrateKbps" class="bitrate">
          ãƒ“ãƒƒãƒˆãƒ¬ãƒ¼ãƒˆ: {{ sound.bitrateKbps }} kbps
        </span>
      </div>
    </div>

    <div class="player-controls">
      <audio
        ref="audioElement"
        :src="sound.blobUrl"
        controls
        class="audio-player"
        @loadedmetadata="onAudioLoaded"
        @timeupdate="onTimeUpdate"
        @ended="onAudioEnded"
      >
        ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°å†ç”Ÿã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚
      </audio>

      <div class="progress-info">
        <span v-if="currentTime > 0" class="current-time">
          {{ formatTime(currentTime) }}
        </span>
        <span v-if="duration > 0" class="total-duration">
          / {{ formatTime(duration) }}
        </span>
      </div>
    </div>

    <div class="actions">
      <button 
        @click="handleDownload" 
        class="download-btn"
        :disabled="downloading"
      >
        {{ downloading ? 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...' : 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰' }}
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
interface Sound {
  id: string
  title: string
  description?: string
  tags?: string[]
  durationSeconds?: number
  bitrateKbps?: number
  blobUrl: string
  thumbnailBlobUrl?: string
  isPublic: boolean
  createdAt: string
}

const props = defineProps<{
  sound: Sound
}>()

const audioElement = ref<HTMLAudioElement>()
const currentTime = ref(0)
const duration = ref(0)
const downloading = ref(false)

const onAudioLoaded = () => {
  if (audioElement.value) {
    duration.value = audioElement.value.duration
  }
}

const onTimeUpdate = () => {
  if (audioElement.value) {
    currentTime.value = audioElement.value.currentTime
  }
}

const onAudioEnded = () => {
  currentTime.value = 0
}

const formatDuration = (seconds: number): string => {
  const minutes = Math.floor(seconds / 60)
  const remainingSeconds = Math.floor(seconds % 60)
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`
}

const formatTime = (seconds: number): string => {
  const minutes = Math.floor(seconds / 60)
  const remainingSeconds = Math.floor(seconds % 60)
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`
}

const handleDownload = async () => {
  try {
    downloading.value = true
    
    const response = await $fetch(`/api/sounds/${props.sound.id}/download`, {
      method: 'GET'
    })

    if (response.success) {
      // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
      const link = document.createElement('a')
      link.href = response.downloadUrl
      link.download = response.filename
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }
  } catch (error: any) {
    console.error('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error)
    alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ')
  } finally {
    downloading.value = false
  }
}
</script>

<style scoped>
.sound-player {
  max-width: 600px;
  margin: 0 auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.sound-info {
  margin-bottom: 2rem;
}

.sound-info h3 {
  margin-bottom: 1rem;
  color: #1f2937;
  font-size: 1.5rem;
}

.description {
  margin-bottom: 1rem;
  color: #6b7280;
  line-height: 1.6;
}

.tags {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.tag {
  padding: 0.25rem 0.75rem;
  background: #e0f2fe;
  color: #0369a1;
  border-radius: 20px;
  font-size: 0.875rem;
  font-weight: 500;
}

.metadata {
  display: flex;
  gap: 1rem;
  font-size: 0.875rem;
  color: #6b7280;
}

.player-controls {
  margin-bottom: 2rem;
}

.audio-player {
  width: 100%;
  margin-bottom: 1rem;
}

.progress-info {
  text-align: center;
  font-size: 0.875rem;
  color: #6b7280;
}

.current-time,
.total-duration {
  font-family: monospace;
}

.actions {
  display: flex;
  justify-content: center;
}

.download-btn {
  padding: 0.75rem 1.5rem;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.download-btn:hover:not(:disabled) {
  background: #2563eb;
}

.download-btn:disabled {
  background: #9ca3af;
  cursor: not-allowed;
}
</style>
</file>

<file path="app/layouts/default.vue">
<template>
    <div class="min-h-screen bg-[url('/background.png')]">
      <!-- å…±é€šãƒ˜ãƒƒãƒ€ãƒ¼ -->
      <header class="flex justify-between items-center p-3 bg-sky-700/40 text-white sticky top-0 left-0 w-full backdrop-blur-md">

      </header>
      <!-- å„ãƒšãƒ¼ã‚¸ã®å†…å®¹ãŒå…¥ã‚‹ -->
      <main class="p-4">
        <slot />
      </main>
      <footer class="inset-x-0 bottom-0 bg-sky-700/40 text-white text-center py-2 backdrop-blur-md">
        <span class="text-sm">&copy; 2025- PATHFINDER. All rights reserved.</span>
      </footer>
    </div>
  </template>
</file>

<file path="database/init.sql">
-- Pathfinder éŸ³æºã‚¢ãƒ—ãƒª ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

-- LoginAccounts table
CREATE TABLE login_accounts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE NOT NULL,
  password_hash text NOT NULL,
  display_name text,
  created_at timestamptz DEFAULT now()
);

-- Sounds table
CREATE TABLE sounds (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  title text NOT NULL,
  description text,
  tags text[],
  duration_seconds numeric,
  bitrate_kbps integer,
  blob_url text NOT NULL,
  thumbnail_blob_url text,
  is_public boolean DEFAULT true,
  author_id uuid REFERENCES login_accounts(id) ON DELETE SET NULL,
  created_at timestamptz DEFAULT now()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä½œæˆ
CREATE INDEX idx_sounds_author_id ON sounds(author_id);
CREATE INDEX idx_sounds_is_public ON sounds(is_public);
CREATE INDEX idx_sounds_created_at ON sounds(created_at);
CREATE INDEX idx_login_accounts_email ON login_accounts(email);
</file>

<file path="public/robots.txt">
User-Agent: *
Disallow:
</file>

<file path="server/api/auth/me.get.ts">
import { query } from '../../utils/db'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  try {
    // Cookieã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const token = getCookie(event, 'Authorization')
    
    if (!token || !token.startsWith('Bearer ')) {
      throw createError({
        statusCode: 401,
        message: 'No valid token provided'
      })
    }

    const tokenValue = token.replace('Bearer ', '')
    
    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
    const decoded = jwt.verify(tokenValue, process.env.JWT_SECRET!) as any
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å–å¾—
    const result = await query(
      'SELECT id, email, display_name, created_at FROM login_accounts WHERE id = $1',
      [decoded.id]
    )

    if (!result.rows.length) {
      throw createError({
        statusCode: 401,
        message: 'User not found'
      })
    }

    const user = result.rows[0]

    return {
      success: true,
      user: {
        id: user.id,
        email: user.email,
        displayName: user.display_name,
        createdAt: user.created_at
      }
    }
  } catch (error: any) {
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      throw createError({
        statusCode: 401,
        message: 'Invalid or expired token'
      })
    }
    
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/api/sounds/[id]/download.get.ts">
import { query } from '../../../utils/db'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  try {
    // Cookieã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const token = getCookie(event, 'Authorization')
    
    if (!token || !token.startsWith('Bearer ')) {
      throw createError({
        statusCode: 401,
        message: 'Authentication required'
      })
    }

    const tokenValue = token.replace('Bearer ', '')
    
    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
    const decoded = jwt.verify(tokenValue, process.env.JWT_SECRET!) as any
    
    const id = getRouterParam(event, 'id')
    
    if (!id) {
      throw createError({
        statusCode: 400,
        message: 'Sound ID is required'
      })
    }

    // éŸ³æºã®æƒ…å ±ã‚’å–å¾—
    const result = await query(
      'SELECT * FROM sounds WHERE id = $1',
      [id]
    )

    if (!result.rows.length) {
      throw createError({
        statusCode: 404,
        message: 'Sound not found'
      })
    }

    const sound = result.rows[0]

    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã®Blob URLã‚’è¿”ã™
    return {
      success: true,
      downloadUrl: sound.blob_url,
      filename: `${sound.title}.mp3` // é©åˆ‡ãªæ‹¡å¼µå­ã«å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
    }
  } catch (error: any) {
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      throw createError({
        statusCode: 401,
        message: 'Invalid or expired token'
      })
    }
    
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/api/sounds/[id]/stream.get.ts">
import { query } from '../../../utils/db'

export default defineEventHandler(async (event) => {
  try {
    const id = getRouterParam(event, 'id')
    
    if (!id) {
      throw createError({
        statusCode: 400,
        message: 'Sound ID is required'
      })
    }

    // éŸ³æºã®æƒ…å ±ã‚’å–å¾—
    const result = await query(
      'SELECT * FROM sounds WHERE id = $1 AND is_public = true',
      [id]
    )

    if (!result.rows.length) {
      throw createError({
        statusCode: 404,
        message: 'Sound not found or not public'
      })
    }

    const sound = result.rows[0]

    return {
      success: true,
      sound: {
        id: sound.id,
        title: sound.title,
        description: sound.description,
        tags: sound.tags,
        durationSeconds: sound.duration_seconds,
        bitrateKbps: sound.bitrate_kbps,
        blobUrl: sound.blob_url,
        thumbnailBlobUrl: sound.thumbnail_blob_url,
        isPublic: sound.is_public,
        createdAt: sound.created_at
      }
    }
  } catch (error: any) {
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/api/sounds/list.get.ts">
import { query } from '../../utils/db'

export default defineEventHandler(async (event) => {
  try {
    // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—
    const queryParams = getQuery(event)
    const limit = parseInt(queryParams.limit as string) || 50
    const offset = parseInt(queryParams.offset as string) || 0
    const authorId = queryParams.authorId as string

    let sql = `
      SELECT 
        s.id, s.title, s.description, s.tags, 
        s.duration_seconds, s.bitrate_kbps, s.blob_url, 
        s.thumbnail_blob_url, s.is_public, s.created_at,
        u.email as author_email, u.display_name as author_display_name
      FROM sounds s
      LEFT JOIN login_accounts u ON s.author_id = u.id
      WHERE s.is_public = true
    `
    
    const params: any[] = []
    let paramIndex = 1

    if (authorId) {
      sql += ` AND s.author_id = $${paramIndex}`
      params.push(authorId)
      paramIndex++
    }

    sql += ` ORDER BY s.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`
    params.push(limit, offset)

    const result = await query(sql, params)

    const sounds = result.rows.map(row => ({
      id: row.id,
      title: row.title,
      description: row.description,
      tags: row.tags || [],
      durationSeconds: row.duration_seconds,
      bitrateKbps: row.bitrate_kbps,
      blobUrl: row.blob_url,
      thumbnailBlobUrl: row.thumbnail_blob_url,
      isPublic: row.is_public,
      createdAt: row.created_at,
      author: {
        email: row.author_email,
        displayName: row.author_display_name
      }
    }))

    return {
      success: true,
      sounds,
      pagination: {
        limit,
        offset,
        total: sounds.length
      }
    }
  } catch (error: any) {
    console.error('List sounds error:', error)
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/api/sounds/metadata.post.ts">
import { query } from '../../utils/db'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  try {
    // Cookieã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const token = getCookie(event, 'Authorization')
    
    if (!token || !token.startsWith('Bearer ')) {
      throw createError({
        statusCode: 401,
        message: 'Authentication required'
      })
    }

    const tokenValue = token.replace('Bearer ', '')
    
    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
    const decoded = jwt.verify(tokenValue, process.env.JWT_SECRET!) as any
    
    const body = await readBody(event)
    const { 
      title, 
      description, 
      tags, 
      durationSeconds, 
      bitrateKbps, 
      blobUrl, 
      thumbnailBlobUrl, 
      isPublic 
    } = body

    if (!title || !blobUrl) {
      throw createError({
        statusCode: 400,
        message: 'Title and blob URL are required'
      })
    }

    // éŸ³æºã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    const result = await query(
      `INSERT INTO sounds (
        title, description, tags, duration_seconds, bitrate_kbps, 
        blob_url, thumbnail_blob_url, is_public, author_id
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) 
      RETURNING id, title, created_at`,
      [
        title,
        description || null,
        tags || [],
        durationSeconds || null,
        bitrateKbps || null,
        blobUrl,
        thumbnailBlobUrl || null,
        isPublic !== undefined ? isPublic : true,
        decoded.id
      ]
    )

    return {
      success: true,
      sound: {
        id: result.rows[0].id,
        title: result.rows[0].title,
        createdAt: result.rows[0].created_at
      }
    }
  } catch (error: any) {
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      throw createError({
        statusCode: 401,
        message: 'Invalid or expired token'
      })
    }
    
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/api/sounds/upload-local.post.ts">
import { saveFile, generateUniqueFilename } from '../../utils/localStorage'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  try {
    // Cookieã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const token = getCookie(event, 'Authorization')
    
    if (!token || !token.startsWith('Bearer ')) {
      throw createError({
        statusCode: 401,
        message: 'Authentication required'
      })
    }

    const tokenValue = token.replace('Bearer ', '')
    
    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
    const decoded = jwt.verify(tokenValue, process.env.JWT_SECRET!) as any
    
    // ãƒãƒ«ãƒãƒ‘ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†
    const formData = await readMultipartFormData(event)
    
    if (!formData) {
      throw createError({
        statusCode: 400,
        message: 'No form data provided'
      })
    }

    let audioFile: any = null
    let title = ''
    let description = ''
    let tags = ''
    let isPublic = 'true'

    // ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŠ½å‡º
    for (const field of formData) {
      if (field.name === 'audioFile' && field.filename) {
        audioFile = field
      } else if (field.name === 'title') {
        title = field.data.toString()
      } else if (field.name === 'description') {
        description = field.data.toString()
      } else if (field.name === 'tags') {
        tags = field.data.toString()
      } else if (field.name === 'isPublic') {
        isPublic = field.data.toString()
      }
    }

    if (!audioFile || !title) {
      throw createError({
        statusCode: 400,
        message: 'Audio file and title are required'
      })
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
    const filename = generateUniqueFilename(audioFile.filename)
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
    const fileUrl = await saveFile(audioFile.data, filename, 'upload')
    
    // éŸ³æºã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    const { query } = await import('../../utils/db')
    
    const result = await query(
      `INSERT INTO sounds (
        title, description, tags, blob_url, is_public, author_id
      ) VALUES ($1, $2, $3, $4, $5, $6) 
      RETURNING id, title, created_at`,
      [
        title,
        description || null,
        tags ? tags.split(',').map(tag => tag.trim()) : [],
        fileUrl,
        isPublic === 'true',
        decoded.id
      ]
    )

    return {
      success: true,
      sound: {
        id: result.rows[0].id,
        title: result.rows[0].title,
        createdAt: result.rows[0].created_at,
        blobUrl: fileUrl
      }
    }
  } catch (error: any) {
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      throw createError({
        statusCode: 401,
        message: 'Invalid or expired token'
      })
    }
    
    if (error.statusCode) {
      throw error
    }
    
    console.error('Upload error:', error)
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/api/sounds/upload-url.post.ts">
import { put } from '@vercel/blob'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  try {
    // Cookieã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    const token = getCookie(event, 'Authorization')
    
    if (!token || !token.startsWith('Bearer ')) {
      throw createError({
        statusCode: 401,
        message: 'Authentication required'
      })
    }

    const tokenValue = token.replace('Bearer ', '')
    
    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
    const decoded = jwt.verify(tokenValue, process.env.JWT_SECRET!) as any
    
    const body = await readBody(event)
    const { filename, contentType } = body

    if (!filename || !contentType) {
      throw createError({
        statusCode: 400,
        message: 'Filename and content type are required'
      })
    }

    // Vercel Blobã®ç½²åä»˜ãURLã‚’ç”Ÿæˆ
    const blob = await put(filename, null, {
      access: 'public',
      token: process.env.BLOB_READ_WRITE_TOKEN
    })

    return {
      success: true,
      uploadUrl: blob.uploadUrl,
      url: blob.url
    }
  } catch (error: any) {
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      throw createError({
        statusCode: 401,
        message: 'Invalid or expired token'
      })
    }
    
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/utils/localStorage.ts">
import { writeFile, unlink, readFile } from 'fs/promises'
import { existsSync } from 'fs'
import path from 'path'
import { randomUUID } from 'crypto'

const STORAGE_PATH = path.join(process.cwd(), 'storage')
const UPLOADS_PATH = path.join(STORAGE_PATH, 'uploads')
const THUMBNAILS_PATH = path.join(STORAGE_PATH, 'thumbnails')

// ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
const ensureDirectories = () => {
  if (!existsSync(STORAGE_PATH)) {
    require('fs').mkdirSync(STORAGE_PATH, { recursive: true })
  }
  if (!existsSync(UPLOADS_PATH)) {
    require('fs').mkdirSync(UPLOADS_PATH, { recursive: true })
  }
  if (!existsSync(THUMBNAILS_PATH)) {
    require('fs').mkdirSync(THUMBNAILS_PATH, { recursive: true })
  }
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜
export const saveFile = async (file: Buffer, filename: string, type: 'upload' | 'thumbnail' = 'upload'): Promise<string> => {
  ensureDirectories()
  
  const storagePath = type === 'upload' ? UPLOADS_PATH : THUMBNAILS_PATH
  const filePath = path.join(storagePath, filename)
  
  await writeFile(filePath, file)
  
  // é–‹ç™ºç’°å¢ƒç”¨ã®ãƒ­ãƒ¼ã‚«ãƒ«URLã‚’è¿”ã™
  const baseUrl = process.env.NODE_ENV === 'production' 
    ? process.env.BASE_URL || 'http://localhost:3000'
    : 'http://localhost:3000'
  
  return `${baseUrl}/storage/${type === 'upload' ? 'uploads' : 'thumbnails'}/${filename}`
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
export const deleteFile = async (filename: string, type: 'upload' | 'thumbnail' = 'upload'): Promise<void> => {
  const storagePath = type === 'upload' ? UPLOADS_PATH : THUMBNAILS_PATH
  const filePath = path.join(storagePath, filename)
  
  if (existsSync(filePath)) {
    await unlink(filePath)
  }
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
export const fileExists = (filename: string, type: 'upload' | 'thumbnail' = 'upload'): boolean => {
  const storagePath = type === 'upload' ? UPLOADS_PATH : THUMBNAILS_PATH
  const filePath = path.join(storagePath, filename)
  return existsSync(filePath)
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
export const readFileContent = async (filename: string, type: 'upload' | 'thumbnail' = 'upload'): Promise<Buffer> => {
  const storagePath = type === 'upload' ? UPLOADS_PATH : THUMBNAILS_PATH
  const filePath = path.join(storagePath, filename)
  
  if (!existsSync(filePath)) {
    throw new Error('File not found')
  }
  
  return await readFile(filePath)
}

// ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
export const generateUniqueFilename = (originalName: string): string => {
  const ext = path.extname(originalName)
  const name = path.basename(originalName, ext)
  const uuid = randomUUID()
  return `${name}_${uuid}${ext}`
}
</file>

<file path="storage/thumbnails/.gitkeep">
# This file ensures the thumbnails directory is tracked by Git
# Actual thumbnail files will be ignored
</file>

<file path="storage/uploads/.gitkeep">
# This file ensures the uploads directory is tracked by Git
# Actual uploaded files will be ignored
</file>

<file path="tsconfig.json">
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="app/components/SoundUpload.vue">
<template>
  <div class="sound-upload">
    <h3>éŸ³æºã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h3>
    
    <!-- ç’°å¢ƒé¸æŠã‚¿ãƒ– -->
    <div class="environment-tabs">
      <button 
        :class="{ active: useLocalStorage }" 
        @click="useLocalStorage = true"
        class="env-tab-btn"
      >
        ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™º
      </button>
      <button 
        :class="{ active: !useLocalStorage }" 
        @click="useLocalStorage = false"
        class="env-tab-btn"
      >
        Vercel Blob
      </button>
    </div>
    
    <form @submit.prevent="handleUpload" class="upload-form">
      <div class="form-group">
        <label for="title">ã‚¿ã‚¤ãƒˆãƒ« *</label>
        <input
          id="title"
          v-model="form.title"
          type="text"
          required
          class="input"
          placeholder="éŸ³æºã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›"
        />
      </div>

      <div class="form-group">
        <label for="description">èª¬æ˜</label>
        <textarea
          id="description"
          v-model="form.description"
          class="textarea"
          placeholder="éŸ³æºã®èª¬æ˜ã‚’å…¥åŠ›"
          rows="3"
        ></textarea>
      </div>

      <div class="form-group">
        <label for="tags">ã‚¿ã‚°ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰</label>
        <input
          id="tags"
          v-model="form.tags"
          type="text"
          class="input"
          placeholder="ã‚¿ã‚°1, ã‚¿ã‚°2, ã‚¿ã‚°3"
        />
      </div>

      <div class="form-group">
        <label for="audioFile">éŸ³æºãƒ•ã‚¡ã‚¤ãƒ« *</label>
        <input
          id="audioFile"
          ref="fileInput"
          type="file"
          accept="audio/*"
          required
          class="file-input"
          @change="handleFileSelect"
        />
        <div v-if="selectedFile" class="file-info">
          é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«: {{ selectedFile.name }}
          <br>
          <small>ã‚µã‚¤ã‚º: {{ formatFileSize(selectedFile.size) }}</small>
        </div>
      </div>

      <div class="form-group">
        <label>
          <input
            v-model="form.isPublic"
            type="checkbox"
            class="checkbox"
          />
          å…¬é–‹ã™ã‚‹
        </label>
      </div>

      <button type="submit" class="upload-btn" :disabled="uploading">
        {{ uploading ? 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...' : 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰' }}
      </button>
    </form>

    <div v-if="error" class="error">
      {{ error }}
    </div>

    <div v-if="success" class="success">
      éŸ³æºã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸï¼
    </div>

    <!-- ç’°å¢ƒæƒ…å ± -->
    <div class="environment-info">
      <p><strong>ç¾åœ¨ã®ç’°å¢ƒ:</strong> {{ useLocalStorage ? 'ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™º' : 'Vercel Blob' }}</p>
      <p v-if="useLocalStorage" class="local-info">
        ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã¯ <code>storage/uploads/</code> ã«ä¿å­˜ã•ã‚Œã¾ã™
      </p>
      <p v-else class="blob-info">
        â˜ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ã¯ Vercel Blob ã«ä¿å­˜ã•ã‚Œã¾ã™
      </p>
    </div>
  </div>
</template>

<script setup lang="ts">
const fileInput = ref<HTMLInputElement>()
const selectedFile = ref<File | null>(null)
const uploading = ref(false)
const error = ref('')
const success = ref('')
const useLocalStorage = ref(true) // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™º

const form = reactive({
  title: '',
  description: '',
  tags: '',
  isPublic: true
})

const emit = defineEmits<{
  uploaded: [sound: any]
}>()

const handleFileSelect = (event: Event) => {
  const target = event.target as HTMLInputElement
  if (target.files && target.files[0]) {
    selectedFile.value = target.files[0]
  }
}

const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

const handleUpload = async () => {
  if (!selectedFile.value) {
    error.value = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„'
    return
  }

  try {
    uploading.value = true
    error.value = ''
    success.value = ''

    if (useLocalStorage.value) {
      // ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒç”¨ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      await handleLocalUpload()
    } else {
      // Vercel Blobç”¨ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      await handleBlobUpload()
    }
  } catch (err: any) {
    error.value = err.data?.message || 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ'
  } finally {
    uploading.value = false
  }
}

const handleLocalUpload = async () => {
  // FormDataã‚’ä½œæˆ
  const formData = new FormData()
  formData.append('title', form.title)
  formData.append('description', form.description)
  formData.append('tags', form.tags)
  formData.append('audioFile', selectedFile.value!)
  formData.append('isPublic', form.isPublic.toString())

  const response = await $fetch('/api/sounds/upload-local', {
    method: 'POST',
    body: formData
  }) as any

  if (response.success) {
    success.value = 'éŸ³æºã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸï¼'
    emit('uploaded', response.sound)
    resetForm()
  }
}

const handleBlobUpload = async () => {
  // 1. ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰URLã‚’å–å¾—
  const uploadUrlResponse = await $fetch('/api/sounds/upload-url', {
    method: 'POST',
    body: {
      filename: selectedFile.value!.name,
      contentType: selectedFile.value!.type
    }
  }) as any

  if (!uploadUrlResponse.success) {
    throw new Error('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰URLã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ')
  }

  // 2. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’Vercel Blobã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
  await fetch(uploadUrlResponse.uploadUrl, {
    method: 'PUT',
    body: selectedFile.value
  })

  // 3. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
  const tags = form.tags ? form.tags.split(',').map(tag => tag.trim()) : []
  
  const metadataResponse = await $fetch('/api/sounds/metadata', {
    method: 'POST',
    body: {
      title: form.title,
      description: form.description,
      tags,
      blobUrl: uploadUrlResponse.url,
      isPublic: form.isPublic
    }
  }) as any

  if (metadataResponse.success) {
    success.value = 'éŸ³æºã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸï¼'
    emit('uploaded', metadataResponse.sound)
    resetForm()
  }
}

const resetForm = () => {
  form.title = ''
  form.description = ''
  form.tags = ''
  form.isPublic = true
  selectedFile.value = null
  if (fileInput.value) {
    fileInput.value.value = ''
  }
}
</script>

<style scoped>
.sound-upload {
  max-width: 600px;
  margin: 0 auto;
  padding: 2rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.sound-upload h3 {
  margin-bottom: 2rem;
  color: #1f2937;
  text-align: center;
}

.environment-tabs {
  display: flex;
  margin-bottom: 2rem;
  background: #f3f4f6;
  border-radius: 8px;
  padding: 0.25rem;
}

.env-tab-btn {
  flex: 1;
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  color: #6b7280;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.2s;
  font-size: 0.875rem;
}

.env-tab-btn.active {
  background: #3b82f6;
  color: white;
}

.env-tab-btn:hover:not(.active) {
  background: #e5e7eb;
}

.upload-form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.form-group label {
  font-weight: 500;
  color: #374151;
}

.input,
.textarea {
  padding: 0.75rem;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 1rem;
  transition: border-color 0.2s;
}

.input:focus,
.textarea:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.textarea {
  resize: vertical;
  min-height: 80px;
}

.file-input {
  padding: 0.5rem;
  border: 2px dashed #d1d5db;
  border-radius: 6px;
  background: #f9fafb;
  cursor: pointer;
  transition: border-color 0.2s;
}

.file-input:hover {
  border-color: #3b82f6;
}

.file-info {
  margin-top: 0.5rem;
  padding: 0.5rem;
  background: #f0f9ff;
  color: #0369a1;
  border-radius: 4px;
  font-size: 0.875rem;
}

.checkbox {
  margin-right: 0.5rem;
}

.upload-btn {
  padding: 0.75rem;
  background: #10b981;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.upload-btn:hover:not(:disabled) {
  background: #059669;
}

.upload-btn:disabled {
  background: #9ca3af;
  cursor: not-allowed;
}

.error {
  margin-bottom: 1rem;
  padding: 0.75rem;
  background: #fef2f2;
  color: #dc2626;
  border: 1px solid #fecaca;
  border-radius: 6px;
  text-align: center;
}

.success {
  margin-bottom: 1rem;
  padding: 0.75rem;
  background: #f0fdf4;
  color: #16a34a;
  border: 1px solid #bbf7d0;
  border-radius: 6px;
  text-align: center;
}

.environment-info {
  padding: 1rem;
  background: #f8fafc;
  border-radius: 6px;
  border-left: 4px solid #3b82f6;
}

.environment-info p {
  margin: 0.5rem 0;
  font-size: 0.875rem;
  color: #374151;
}

.environment-info code {
  background: #e5e7eb;
  padding: 0.125rem 0.25rem;
  border-radius: 4px;
  font-family: monospace;
}

.local-info {
  color: #059669;
}

.blob-info {
  color: #7c3aed;
}
</style>
</file>

<file path="app/app.vue">
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
</file>

<file path="server/api/auth/login.post.ts">
import { query } from '../../utils/db'
import bcrypt from 'bcrypt'
import jwt from 'jsonwebtoken'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event)
    const { email, password } = body

    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!email || !password) {
      throw createError({
        statusCode: 400,
        message: 'Email and password are required'
      })
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¤œç´¢
    const result = await query(
      'SELECT * FROM login_accounts WHERE email = $1',
      [email]
    )

    if (!result.rows.length) {
      throw createError({
        statusCode: 401,
        message: 'Invalid credentials'
      })
    }

    const user = result.rows[0]

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®æ¤œè¨¼
    const match = await bcrypt.compare(password, user.password_hash)
    if (!match) {
      throw createError({
        statusCode: 401,
        message: 'Invalid credentials'
      })
    }

    // JWTãƒˆãƒ¼ã‚¯ãƒ³ã®ç”Ÿæˆ
    const token = jwt.sign(
      { id: user.id, email: user.email },
      process.env.JWT_SECRET!,
      { expiresIn: '7d' }
    )

    // Cookieã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¨­å®š
    setCookie(event, 'Authorization', `Bearer ${token}`, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 7 * 24 * 60 * 60 // 7 days
    })

    return {
      success: true,
      user: {
        id: user.id,
        email: user.email,
        displayName: user.display_name
      }
    }
  } catch (error: any) {
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/api/auth/register.post.ts">
import { query } from '../../utils/db'
import bcrypt from 'bcrypt'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody(event)
    const { email, password, displayName } = body

    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!email || !password) {
      throw createError({
        statusCode: 400,
        message: 'Email and password are required'
      })
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒãƒƒã‚·ãƒ¥åŒ–
    const saltRounds = 10
    const passwordHash = await bcrypt.hash(password, saltRounds)

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆ
    const result = await query(
      'INSERT INTO login_accounts (email, password_hash, display_name) VALUES ($1, $2, $3) RETURNING id, email, display_name, created_at',
      [email, passwordHash, displayName || null]
    )

    return {
      success: true,
      user: {
        id: result.rows[0].id,
        email: result.rows[0].email,
        displayName: result.rows[0].display_name,
        createdAt: result.rows[0].created_at
      }
    }
  } catch (error: any) {
    if (error.code === '23505') { // unique_violation
      throw createError({
        statusCode: 409,
        message: 'Email already exists'
      })
    }
    
    throw createError({
      statusCode: 500,
      message: 'Internal server error'
    })
  }
})
</file>

<file path="server/utils/db.ts">
import pg from 'pg'

const config = useRuntimeConfig()

const pool = new pg.Pool({ 
  connectionString: config.databaseUrl,
  ssl: config.public.nodeEnv === 'production' ? { rejectUnauthorized: false } : false
})

export const query = (text: string, params?: any[]) => pool.query(text, params)

export const closePool = () => pool.end()
</file>

<file path=".gitignore">
# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist

# Node dependencies
node_modules

# Logs
*.log

# Misc
.DS_Store
.fleet
.idea

# Local env files
.env
.env.*
!.env.example

# Storage directories (for development)
storage/uploads/*
storage/thumbnails/*
!storage/uploads/.gitkeep
!storage/thumbnails/.gitkeep

# Vercel
.vercel
</file>

<file path="nuxt.config.ts">
import tailwindcss from "@tailwindcss/vite";

export default defineNuxtConfig({
  compatibilityDate: '2025-07-15',
  devtools: { enabled: true },
  css: ['~/assets/css/style.css'],
  vite: {
    plugins: [
      tailwindcss(),
    ],
  },
  modules: ['@nuxt/test-utils', '@nuxt/ui', '@pinia/nuxt'],
  
  // ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
  runtimeConfig: {
    // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã®ã¿åˆ©ç”¨å¯èƒ½
    databaseUrl: process.env.DATABASE_URL,
    jwtSecret: process.env.JWT_SECRET,
    blobReadWriteToken: process.env.BLOB_READ_WRITE_TOKEN,
    
    // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ã‚‚åˆ©ç”¨å¯èƒ½
    public: {
      nodeEnv: process.env.NODE_ENV
    }
  },
  
  // content: {
  // },
});
</file>

<file path="README.md">
# ğŸµ Pathfinder - éŸ³æºå…±æœ‰ã‚¢ãƒ—ãƒª

Nuxt4 + Vercel Blob + PostgreSQL ã‚’ä½¿ç”¨ã—ãŸéŸ³æºå…±æœ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚

## âœ¨ æ©Ÿèƒ½

- ğŸ” JWTèªè¨¼ã«ã‚ˆã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†
- ğŸ“¤ éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆVercel Blobï¼‰
- ğŸµ éŸ³æºã®å†ç”Ÿãƒ»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
- ğŸ·ï¸ ã‚¿ã‚°ä»˜ã‘ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç®¡ç†
- ğŸ“± ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³

## ğŸš€ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### 1. ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
pnpm install
```

### 2. ç’°å¢ƒå¤‰æ•°ã®è¨­å®š

`.env` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã€ä»¥ä¸‹ã®ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„ï¼š

```env
# Database
DATABASE_URL=postgresql://username:password@localhost:5432/pathfinder

# JWT
JWT_SECRET=your-super-secret-jwt-key-here

# Vercel Blob
BLOB_READ_WRITE_TOKEN=your-vercel-blob-token-here
```

### 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆæœŸåŒ–

PostgreSQLãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã—ã€`database/init.sql` ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼š

```bash
psql -d pathfinder -f database/init.sql
```

### 4. é–‹ç™ºã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•

```bash
pnpm dev
```

## ğŸ§ª é–‹ç™ºç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆ

### ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ä½¿ç”¨

é–‹ç™ºç’°å¢ƒã§ã¯ã€éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã® `storage/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ä¿å­˜ã§ãã¾ã™ï¼š

- `storage/uploads/` - éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«
- `storage/thumbnails/` - ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒ

ã“ã‚Œã«ã‚ˆã‚Šã€Vercel Blobã®è¨­å®šãªã—ã§ã‚‚éŸ³æºã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ãƒ†ã‚¹ãƒˆãŒå¯èƒ½ã§ã™ã€‚

### ç’°å¢ƒåˆ‡ã‚Šæ›¿ãˆ

ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”»é¢ã§ã€Œãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºã€ã¨ã€ŒVercel Blobã€ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ãƒ†ã‚¹ãƒˆã§ãã¾ã™ã€‚

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆNuxt Nitro APIï¼‰

- **èªè¨¼**: JWT + Cookie
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: PostgreSQLï¼ˆORMä¸ä½¿ç”¨ã€DDLç›´æ›¸ãï¼‰
- **ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸**: Vercel Blob
- **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥**: bcrypt

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: Nuxt 4 + Vue 3
- **ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°**: CSSï¼ˆTailwindä¸ä½¿ç”¨ï¼‰
- **çŠ¶æ…‹ç®¡ç†**: Vue Composition API

## ğŸ“¡ API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

| Method | Path | èª¬æ˜ | èªè¨¼ |
|--------|------|------|------|
| POST | `/api/auth/register` | æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ² | âŒ |
| POST | `/api/auth/login` | JWTãƒ­ã‚°ã‚¤ãƒ³ | âŒ |
| GET | `/api/auth/me` | ãƒ­ã‚°ã‚¤ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ± | âœ… |
| POST | `/api/sounds/upload-url` | éŸ³æºã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰URLç™ºè¡Œ | âœ… |
| POST | `/api/sounds/metadata` | éŸ³æºãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç™»éŒ² | âœ… |
| GET | `/api/sounds/:id/stream` | éŸ³æºå†ç”Ÿ | âŒ |
| GET | `/api/sounds/:id/download` | éŸ³æºãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ | âœ… |

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤

### Vercel

1. Vercel Blobã‚’æœ‰åŠ¹åŒ–ï¼š
```bash
vercel storage link
```

2. ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šï¼š
   - `DATABASE_URL`
   - `BLOB_READ_WRITE_TOKEN`
   - `JWT_SECRET`

3. ãƒ‡ãƒ—ãƒ­ã‚¤ï¼š
```bash
vercel --prod
```

## ğŸ”§ é–‹ç™º

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š

```typescript
import { query } from '~/server/utils/db'

// ã‚¯ã‚¨ãƒªã®å®Ÿè¡Œ
const result = await query('SELECT * FROM sounds WHERE is_public = true')
```

### èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢

```typescript
// Cookieã‹ã‚‰JWTãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
const token = getCookie(event, 'Authorization')
if (!token || !token.startsWith('Bearer ')) {
  throw createError({ statusCode: 401, message: 'Authentication required' })
}
```

## ğŸ“ æ³¨æ„äº‹é …

- Prismaãªã©ã®ORMã¯ä½¿ç”¨ã—ã¦ã„ã¾ã›ã‚“
- ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯SQLãƒ•ã‚¡ã‚¤ãƒ«ã§æ‰‹å‹•ç®¡ç†
- éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›ã¯è¡Œã‚ãšã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’é…ä¿¡
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¯JWT + Cookieã§å®Ÿè£…

## ğŸ¤ ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³

1. ã“ã®ãƒªãƒã‚¸ãƒˆãƒªã‚’ãƒ•ã‚©ãƒ¼ã‚¯
2. ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ
3. å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
4. ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆ

## ğŸ“„ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

MIT License
</file>

<file path="app/pages/index.vue">
<script setup lang="ts">
import { useAuthStore } from '~/stores/auth'
import { useSoundsStore } from '~/stores/sounds'

const authStore = useAuthStore()
const soundsStore = useSoundsStore()

const activeTab = ref<'upload' | 'browse'>('upload')

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ç¢ºèª
onMounted(async () => {
  await authStore.checkAuth()
  if (authStore.isLoggedIn) {
    await soundsStore.fetchSounds()
  }
})

const handleAuthSuccess = async () => {
  await soundsStore.fetchSounds()
}

const handleLogout = () => {
  authStore.logout()
  soundsStore.$reset()
  activeTab.value = 'upload'
}

const handleSoundUploaded = async () => {
  activeTab.value = 'browse'
}
</script>

<template>
  <div class="container">
    <header class="header">
      <h1>ğŸµ Pathfinder - éŸ³æºå…±æœ‰ã‚¢ãƒ—ãƒª</h1>
      <p>ã‚ãªãŸã®éŸ³æºã‚’ä¸–ç•Œã¨å…±æœ‰ã—ã¾ã—ã‚‡ã†</p>
    </header>

    <main class="main">
      <!-- æœªãƒ­ã‚°ã‚¤ãƒ³æ™‚ã¯èªè¨¼ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¡¨ç¤º -->
      <div v-if="!authStore.isLoggedIn" class="auth-section">
        <AuthForm @success="handleAuthSuccess" />
      </div>

      <!-- ãƒ­ã‚°ã‚¤ãƒ³å¾Œã¯éŸ³æºã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨å†ç”Ÿã‚’è¡¨ç¤º -->
      <div v-else class="user-section">
        <div class="user-info">
          <h2>ã‚ˆã†ã“ãã€{{ authStore.currentUser?.displayName || authStore.currentUser?.email }}ã•ã‚“ï¼</h2>
          <button @click="handleLogout" class="logout-btn">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
        </div>

        <div class="content-tabs">
          <button 
            :class="{ active: activeTab === 'upload' }" 
            @click="activeTab = 'upload'"
            class="tab-btn"
          >
            éŸ³æºã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
          </button>
          <button 
            :class="{ active: activeTab === 'browse' }" 
            @click="activeTab = 'browse'"
            class="tab-btn"
          >
            éŸ³æºã‚’è´ã
          </button>
        </div>

        <div v-if="activeTab === 'upload'" class="tab-content">
          <SoundUpload @uploaded="handleSoundUploaded" />
        </div>

        <div v-else-if="activeTab === 'browse'" class="tab-content">
          <div v-if="soundsStore.sounds.length === 0" class="no-sounds">
            <p>ã¾ã éŸ³æºãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>
            <p>æœ€åˆã®éŸ³æºã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã¿ã¾ã—ã‚‡ã†ï¼</p>
          </div>
          
          <div v-else class="sounds-list">
            <SoundPlayer 
              v-for="sound in soundsStore.sounds" 
              :key="sound.id" 
              :sound="sound" 
            />
          </div>
        </div>
      </div>
    </main>
  </div>
</template>

<style scoped>
.container {
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 2rem;
}

.header {
  text-align: center;
  margin-bottom: 3rem;
  color: white;
}

.header h1 {
  font-size: 3rem;
  margin-bottom: 1rem;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.header p {
  font-size: 1.25rem;
  opacity: 0.9;
}

.main {
  max-width: 1200px;
  margin: 0 auto;
}

.auth-section {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 60vh;
}

.user-section {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 16px;
  padding: 2rem;
  backdrop-filter: blur(10px);
}

.user-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.user-info h2 {
  color: white;
  margin: 0;
}

.logout-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.logout-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}

.content-tabs {
  display: flex;
  margin-bottom: 2rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: 0.25rem;
}

.tab-btn {
  flex: 1;
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.2s;
}

.tab-btn.active {
  background: rgba(255, 255, 255, 0.2);
  color: white;
}

.tab-btn:hover:not(.active) {
  background: rgba(255, 255, 255, 0.1);
}

.tab-content {
  background: white;
  border-radius: 8px;
  padding: 2rem;
  min-height: 400px;
}

.no-sounds {
  text-align: center;
  color: #6b7280;
  padding: 4rem 2rem;
}

.no-sounds p {
  margin-bottom: 0.5rem;
}

.sounds-list {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

@media (max-width: 768px) {
  .container {
    padding: 1rem;
  }
  
  .header h1 {
    font-size: 2rem;
  }
  
  .user-info {
    flex-direction: column;
    gap: 1rem;
    text-align: center;
  }
}
</style>
</file>

<file path="package.json">
{
  "name": "nuxt-app",
  "type": "module",
  "private": true,
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@nuxt/test-utils": "3.19.2",
    "@nuxt/ui": "3.3.0",
    "@pinia/nuxt": "^0.11.2",
    "@tailwindcss/vite": "^4.1.11",
    "@vercel/blob": "^1.1.1",
    "bcrypt": "^6.0.0",
    "jsonwebtoken": "^9.0.2",
    "nuxt": "^4.0.3",
    "pg": "^8.16.3",
    "pinia": "^3.0.3",
    "tailwindcss": "^4.1.11",
    "typescript": "^5.6.3",
    "vue": "^3.5.18",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/pg": "^8.15.5"
  }
}
</file>

</files>
